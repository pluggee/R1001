C51 COMPILER V9.53.0.0   INTERRUPTS                                                        02/14/2017 19:28:45 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE INTERRUPTS
OBJECT MODULE PLACED IN .\src/Interrupts.OBJ
COMPILER INVOKED BY: Z:\Applications\SimplicityStudio_v3\developer\toolchains\keil_8051\9.53\BIN\C51.exe /Users/sherifei
                    -d/plugge_git/R1001/firmware/R1001_bl/src/Interrupts.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZ
                    -Y(3) OPTIMIZE(9,SPEED) DEFINE(NDEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(/Users/sherifeid/plugge_git/R1001/firmware/R
                    -1001_bl/inc;/Applications/SimplicityStudio_v3/developer/sdks/si8051/v3//Device/shared/si8051Base;/Applications/Simplicit
                    -yStudio_v3/developer/sdks/si8051/v3//Device/EFM8BB1;/Applications/SimplicityStudio_v3/developer/sdks/si8051/v3//Device/E
                    -FM8BB1/inc) REGFILE(R1001_bl.ORC) PRINT(.\src/Interrupts.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src/Interrupts
                    -.OBJ)

line level    source

   1          //=========================================================
   2          // src/Interrupts.c: generated by Hardware Configurator
   3          //
   4          // This file will be regenerated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!
   7          //=========================================================
   8          
   9          // USER INCLUDES
  10          #include <SI_EFM8BB1_Register_Enums.h>
  11          #include "smb.h"
  12          #include "R1001_bl_main.h"
  13          
  14          //-----------------------------------------------------------------------------
  15          // SMBUS0_ISR
  16          //-----------------------------------------------------------------------------
  17          //
  18          // SMBUS0 ISR Content goes here. Remember to clear flag bits:
  19          // SMB0CN0::SI (SMBus Interrupt Flag)
  20          //
  21          //-----------------------------------------------------------------------------
  22          //SI_INTERRUPT (SMBUS0_ISR, SMBUS0_IRQn)
  23          //{
  24          //    RunSMBHandler();
  25          //}
  26          
  27          //-----------------------------------------------------------------------------
  28          // SMBUS0_ISR
  29          //-----------------------------------------------------------------------------
  30          //
  31          // SMBUS0 ISR Content goes here. Remember to clear flag bits:
  32          // SMB0CN0::SI (SMBus Interrupt Flag)
  33          //
  34          //-----------------------------------------------------------------------------
  35          SI_INTERRUPT (SMBUS0_ISR, SMBUS0_IRQn){
  36   1          static uint8_t sent_byte_counter;
  37   1          static uint8_t rec_byte_counter;
  38   1      
  39   1          if (SMB0CN0_ARBLOST == 0)
  40   1          {
  41   2              switch (SMB0CN0 & 0xF0)          // Decode the SMBus status vector
  42   2              {
  43   3                  // Slave Receiver: Start+Slave Address received
  44   3                  case SMB_SRADD:
  45   3                      SMB0CN0_STA = 0;// Clear SMB0CN0_STA bit
  46   3      
  47   3                      sent_byte_counter = 1;// Reinitialize the data counters
  48   3                      rec_byte_counter = 1;
  49   3      
  50   3                      // need to add an acknowledge here????
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        02/14/2017 19:28:45 PAGE 2   

  51   3                      // added an ack here
  52   3                      SMB0CN0_ACK = 1;// send an acknowledge that address and command are received
  53   3      
  54   3                      if ((SMB0DAT & 0x01) == READ)// If the transfer is a master READ,
  55   3                      {
  56   4                          // Prepare outgoing byte
  57   4                          SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
  58   4                          sent_byte_counter++;
  59   4                      }
  60   3      
  61   3                      break;
  62   3      
  63   3                  // Slave Receiver: Data received
  64   3                  case SMB_SRDB:
  65   3                      if (rec_byte_counter < TGT_BL_BUF_SIZE)
  66   3                      {
  67   4                          // Store incoming data
  68   4                          SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT;
  69   4                          rec_byte_counter++;
  70   4                          SMB0CN0_ACK = 1;         // SMB0CN0_ACK received data
  71   4                      }
  72   3                      else
  73   3                      {
  74   4                          // Store incoming data
  75   4                          SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT;
  76   4                          DATA_READY = 1;         // Indicate new data fully received
  77   4                      }
  78   3                      break;
  79   3      
  80   3                  // Slave Receiver: Stop received while either a Slave Receiver or
  81   3                  // Slave Transmitter
  82   3                  case SMB_SRSTO:
  83   3                      SMB0CN0_STO = 0;            // SMB0CN0_STO must be cleared by software when
  84   3                                                  // a STOP is detected as a slave
  85   3      
  86   3                      DATA_READY = 1;             // Indicates end of transmission
  87   3                      break;
  88   3      
  89   3                  // Slave Transmitter: Data byte transmitted
  90   3                  case SMB_STDB:
  91   3                      if (SMB0CN0_ACK == 1)// If Master SMB0CN0_ACK's, send the next byte
  92   3                      {
  93   4                          if (sent_byte_counter <= TGT_BL_BUF_SIZE)
  94   4                          {
  95   5                              // Prepare next outgoing byte
  96   5                              SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
  97   5                              sent_byte_counter++;
  98   5                          }
  99   4                      }                          // Otherwise, do nothing
 100   3                      break;
 101   3      
 102   3                  // Slave Transmitter: Arbitration lost, Stop detected
 103   3                  //
 104   3                  // This state will only be entered on a bus error condition.
 105   3                  // In normal operation, the slave is no longer sending data or has
 106   3                  // data pending when a STOP is received from the master, so the SMB0CN0_TXMODE
 107   3                  // bit is cleared and the slave goes to the SRSTO state.
 108   3                  case SMB_STSTO:
 109   3                      SMB0CN0_STO = 0;            // SMB0CN0_STO must be cleared by software when
 110   3                                                  // a STOP is detected as a slave
 111   3                      break;
 112   3      
 113   3                // Default: all other cases undefined
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        02/14/2017 19:28:45 PAGE 3   

 114   3                  default:
 115   3                      SMB0CF &= ~0x80;// Reset communication
 116   3                      SMB0CF |= 0x80;
 117   3                      SMB0CN0_STA = 0;
 118   3                      SMB0CN0_STO = 0;
 119   3                      SMB0CN0_ACK = 1;
 120   3                      break;
 121   3              }
 122   2          }
 123   1          // SMB0CN0_ARBLOST = 1, Abort failed transfer
 124   1          else
 125   1          {
 126   2              SMB0CN0_STA = 0;
 127   2              SMB0CN0_STO = 0;
 128   2              SMB0CN0_ACK = 1;
 129   2          }
 130   1      
 131   1          SMB0CN0_SI = 0;                     // Clear SMBus interrupt flag
 132   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    138    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
