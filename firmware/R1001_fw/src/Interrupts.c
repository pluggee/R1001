//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

// USER INCLUDES
#include <SI_EFM8BB1_Register_Enums.h>
#include "compiler_defs.h"
#include "i2c.h"
#include "global.h"
#include "math.h"
#include "InfoBlock.h"
#include "imon.h"

char writelen = 0;

// LSBSize = 1.65V/(2^12) = 0.000402V

// For 16 samples
//#define SAMPLING_2N             4			// number of samples (power of 2)
//#define SAMPLING_NUMBER         16			// = 2^SAMPLING_2N
//#define TSLOPE                	113			// slope LSB's/C = round(SAMPLING_NUMBER*DS_SLOPE/LSBSize)
//#define TOFFSET                 30067		// Offset in LSB's = round(SAMPLING_NUMBER*DS_OFFSET/LSBSize)

// For a single sample
//#define SAMPLING_2N             0           // number of samples (power of 2)
//#define SAMPLING_NUMBER         1          // = 2^SAMPLING_2N
//#define TSLOPE                  7         // slope LSB's/C = round(SAMPLING_NUMBER*DS_SLOPE/LSBSize)
//#define TOFFSET                 30067       // Offset in LSB's = round(SAMPLING_NUMBER*DS_OFFSET/LSBSize)


// pin declarations
//SBIT(PWMREF, SFR_P1, 4);            						// Driver mode2 pin

//-----------------------------------------------------------------------------
// TIMER0_ISR
//-----------------------------------------------------------------------------
//
// TIMER0 ISR Content goes here. Remember to clear flag bits:
// TCON::TF0 (Timer 0 Overflow Flag)
//
//-----------------------------------------------------------------------------
//SI_INTERRUPT (TIMER0_ISR, TIMER0_IRQn)
//{
//}

//-----------------------------------------------------------------------------
// SMBUS0_ISR
//-----------------------------------------------------------------------------
//
// SMBUS0 ISR Content goes here. Remember to clear flag bits:
// SMB0CN0::SI (SMBus Interrupt Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (SMBUS0_ISR, SMBUS0_IRQn)
{
    static uint8_t sent_byte_counter;
    static uint8_t rec_byte_counter;

    if (SMB0CN0_ARBLOST == 0)
    {
        switch (SMB0CN0 & 0xF0)          // Decode the SMBus status vector
        {
            // Slave Receiver: Start+Slave Address received
            case SMB_SRADD:
            SMB0CN0_STA = 0;// Clear SMB0CN0_STA bit

            sent_byte_counter = 1;// Reinitialize the data counters
            rec_byte_counter = 1;

            if ((SMB0DAT & 0x01) == READ)// If the transfer is a master READ,
            {
                // Prepare outgoing byte
                SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
                sent_byte_counter++;
            }

            // need to add an acknowledge here????
            // added an ack here
            SMB0CN0_ACK = 1;// send an acknowledge that address and command are received

            break;

            // Slave Receiver: Data received
            case SMB_SRDB:
            if (rec_byte_counter < NUM_BYTES_WR)
            {
                // Store incoming data
                SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT;
                rec_byte_counter++;
                SMB0CN0_ACK = 1;// SMB0CN0_ACK received data
            }
            else
            {
                // Store incoming data
                SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT;
                DATA_READY = 1;// Indicate new data fully received
            }
            writelen++;                 // increment global write length counter
            break;

            // Slave Receiver: Stop received while either a Slave Receiver or
            // Slave Transmitter
            case SMB_SRSTO:
            SMB0CN0_STO = 0;// SMB0CN0_STO must be cleared by software when
                            // a STOP is detected as a slave

            DATA_READY = 1;// Indicates end of transmission
            break;

            // Slave Transmitter: Data byte transmitted
            case SMB_STDB:
            if (SMB0CN0_ACK == 1)// If Master SMB0CN0_ACK's, send the next byte
            {
                if (sent_byte_counter <= NUM_BYTES_RD)
                {
                    // Prepare next outgoing byte
                    SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
                    sent_byte_counter++;
                }
            }                          // Otherwise, do nothing
            break;

            // Slave Transmitter: Arbitration lost, Stop detected
            //
            // This state will only be entered on a bus error condition.
            // In normal operation, the slave is no longer sending data or has
            // data pending when a STOP is received from the master, so the SMB0CN0_TXMODE
            // bit is cleared and the slave goes to the SRSTO state.
            case SMB_STSTO:
            SMB0CN0_STO = 0;// SMB0CN0_STO must be cleared by software when
                            // a STOP is detected as a slave
            break;

                            // Default: all other cases undefined
            default:
            SMB0CF &= ~0x80;// Reset communication
            SMB0CF |= 0x80;
            SMB0CN0_STA = 0;
            SMB0CN0_STO = 0;
            SMB0CN0_ACK = 1;
            break;
        }
    }
    // SMB0CN0_ARBLOST = 1, Abort failed transfer
    else
    {
        SMB0CN0_STA = 0;
        SMB0CN0_STO = 0;
        SMB0CN0_ACK = 1;
    }

    SMB0CN0_SI = 0;                     // Clear SMBus interrupt flag

    if (DATA_READY == 1)
    {
        DATA_READY = 0;

        // now we look at the contents of the data in the buffer and act accordingly
        switch(SMB_DATA_IN[0]){
            case TGT_CMD_RESET_MCU:
                // soft reset MCU
                RSTSRC = 0x12;                  // Initiate software reset with vdd monitor enabled
                break;
            case TGT_CMD_PLID:
                // Return platform ID
                // Prepare buffer with ID string
                SMB_DATA_OUT[0] = PLATFORM;     // Platform ID
                break;
            case TGT_CMD_DVID:
                // Return device ID
                // Prepare buffer with ID string
                SMB_DATA_OUT[0] = DEVID;        // device ID
                break;
            case TGT_CMD_FWID:
                // Return firmware VER
                // Prepare buffer with ID string
                SMB_DATA_OUT[0] = APP_FW_VERSION_LOW;           // firmware version - low byte
                SMB_DATA_OUT[1] = APP_FW_VERSION_HIGH;          // firmware version - high byte
                break;
            case TGT_CMD_TMP:
                // This reads out the temperature value
                SMB_DATA_OUT[0] = temp_val;
                break;
            case TGT_CMD_VDD:
                SMB_DATA_OUT[0] = vdd_val & 0xff;               // lower byte
                SMB_DATA_OUT[1] = (vdd_val >> 8) & 0xff;        // upper byte
                break;
            case TGT_CMD_BLSTAT:
                SMB_DATA_OUT[0] = 0x00;                         // indicating application mode
                break;
            case TGT_CMD_STP:
                // Set stepper motor stepping resolution
                // This is a command to change stepping resolution, set it to the value stored in SMB_DATA_IN[1]
                if (writelen > 1){
                    StepRes = SMB_DATA_IN[1];       // store new value to internal variable
                    if ((StepRes > 5) || (StepRes < 0)) {       // Limit step res to the proper range
                        StepRes = 5;
                    }
                    flag_setstep = 1;               // flag to apply new stepping resolution setting
                }
                SMB_DATA_OUT[0] = StepRes;
                // limit the range of StepRes
                break;
            case TGT_CMD_IDRVL:
                // here we check if writing to IDRVL and IDRVH
                if (writelen == 2){
                    // only write IDRVL
                    IDRVL = SMB_DATA_IN[1];         // store new value to internal variable
                    flag_setcurr = 1;               // flag to execute set driver current
                }
                else if (writelen > 2){
                    // write IDRVL & IDRVH
                    IDRVL = SMB_DATA_IN[1];         // store new value to internal variable
                    IDRVH = SMB_DATA_IN[2];         // store new value to internal variable
                    flag_setcurr = 1;               // flag to execute set driver current
                }

                // Store IDRVL/H values into output buffer
                SMB_DATA_OUT[0] = IDRVL;
                SMB_DATA_OUT[1] = IDRVH;
                break;
            case TGT_CMD_IDRVH:
                // here we check if writing to IDRVH
                if (writelen > 1){
                    // only write IDRVH
                    IDRVH = SMB_DATA_IN[1];         // store new value to internal variable
                    flag_setcurr = 1;               // flag to execute set driver current
                }
                // Store IDRVH value in output buffer
                SMB_DATA_OUT[0] = IDRVH;
                break;
            case TGT_CMD_MCTL:
                // Stepper driver control register
                if (writelen > 1){
                    // parse input and execute values
                    MCTL = SMB_DATA_IN[1];          // store new value to internal variable
                    flag_refmctl = 1;               // flag to refresh MCTL reg
                }
                SMB_DATA_OUT[0] = MCTL;             // place refreshed MCTL value in output buffer
                break;
            case TGT_CMD_MSTAT:
                SMB_DATA_OUT[0] = MSTAT;            // place refreshed MCTL value in output buffer
                break;
            case TGT_CMD_IDRIVER:
                // push measure driver current to output buffer
                SMB_DATA_OUT[0] = idrive.c[0];
                SMB_DATA_OUT[1] = idrive.c[1];
                SMB_DATA_OUT[2] = idrive.c[2];
                SMB_DATA_OUT[3] = idrive.c[3];
                break;
            default:
                break;
        }
        writelen = 0;                           // reset writelen counter
   }
}


