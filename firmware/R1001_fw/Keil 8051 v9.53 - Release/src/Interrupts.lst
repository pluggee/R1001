C51 COMPILER V9.53.0.0   INTERRUPTS                                                        10/24/2016 21:38:09 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE INTERRUPTS
OBJECT MODULE PLACED IN .\src/Interrupts.OBJ
COMPILER INVOKED BY: Z:\Applications\SimplicityStudio_v3\developer\toolchains\keil_8051\9.53\BIN\C51.exe /Users/sherifei
                    -d/plugge_git/R1001/firmware/R1001_fw/src/Interrupts.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZ
                    -Y(3) OPTIMIZE(9,SPEED) DEFINE(NDEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(/Users/sherifeid/plugge_git/R1001/firmware/R
                    -1001_fw/inc;/Applications/SimplicityStudio_v3/developer/sdks/si8051/v3//Device/shared/si8051Base;/Applications/Simplicit
                    -yStudio_v3/developer/sdks/si8051/v3//Device/EFM8BB1;/Applications/SimplicityStudio_v3/developer/sdks/si8051/v3//Device/E
                    -FM8BB1/inc) REGFILE(R1001_fw.ORC) PRINT(.\src/Interrupts.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src/Interrupts
                    -.OBJ)

line level    source

   1          //=========================================================
   2          // src/Interrupts.c: generated by Hardware Configurator
   3          //
   4          // This file will be regenerated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!
   7          //=========================================================
   8          
   9          // USER INCLUDES
  10          #include <SI_EFM8BB1_Register_Enums.h>
  11          #include "compiler_defs.h"
  12          #include "i2c.h"
  13          #include "global.h"
  14          #include "math.h"
  15          
  16          
  17          //extern uint32_t ADC_SUM;               // Accumulates the ADC samples
  18          //extern bit CONV_COMPLETE;              // ADC accumulated result ready flag
  19          
  20          uint32_t ADC_SUM;                           // Accumulates the ADC samples
  21          //bit CONV_COMPLETE;                        // ADC accumulated result ready flag
  22          char temp_val;
  23          char TSUM[4];                               // bytes of ADC SUM
  24          char TADCH, TADCL;                          // bytes for single ADC read
  25          
  26          char writelen = 0;
  27          
  28          // temperature sensor constants
  29          #define DS_SLOPE                                0.00285         // slope from datasheet in V/C
  30          #define DS_OFFSET                               0.757           // offset from datasheet in V
  31          
  32          #define SAMPLING_2N             4                       // number of samples (power of 2)
  33          #define SAMPLING_NUMBER         16                      // = 2^SAMPLING_2N
  34          #define TSLOPE                  113                     // slope LSB's/C = round(SAMPLING_NUMBER*DS_SLOPE/LSBSize)
  35          #define TOFFSET                 30067           // Offset in LSB's = round(SAMPLING_NUMBER*DS_OFFSET/LSBSize)
  36          
  37          // pin declarations
  38          //SBIT(PWMREF, SFR_P1, 4);                                                      // Driver mode2 pin
  39          
  40          //-----------------------------------------------------------------------------
  41          // TIMER0_ISR
  42          //-----------------------------------------------------------------------------
  43          //
  44          // TIMER0 ISR Content goes here. Remember to clear flag bits:
  45          // TCON::TF0 (Timer 0 Overflow Flag)
  46          //
  47          //-----------------------------------------------------------------------------
  48          //SI_INTERRUPT (TIMER0_ISR, TIMER0_IRQn)
  49          //{
  50          //}
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        10/24/2016 21:38:09 PAGE 2   

  51          
  52          //-----------------------------------------------------------------------------
  53          // SMBUS0_ISR
  54          //-----------------------------------------------------------------------------
  55          //
  56          // SMBUS0 ISR Content goes here. Remember to clear flag bits:
  57          // SMB0CN0::SI (SMBus Interrupt Flag)
  58          //
  59          //-----------------------------------------------------------------------------
  60          SI_INTERRUPT (SMBUS0_ISR, SMBUS0_IRQn)
  61          {
  62   1              static uint8_t sent_byte_counter;
  63   1              static uint8_t rec_byte_counter;
  64   1      
  65   1              if (SMB0CN0_ARBLOST == 0)
  66   1              {
  67   2                      switch (SMB0CN0 & 0xF0)          // Decode the SMBus status vector
  68   2                      {
  69   3                              // Slave Receiver: Start+Slave Address received
  70   3                              case SMB_SRADD:
  71   3                      SMB0CN0_STA = 0;// Clear SMB0CN0_STA bit
  72   3      
  73   3                      sent_byte_counter = 1;// Reinitialize the data counters
  74   3                      rec_byte_counter = 1;
  75   3      
  76   3                      if ((SMB0DAT & 0x01) == READ)// If the transfer is a master READ,
  77   3                      {
  78   4                          // Prepare outgoing byte
  79   4                          SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
  80   4                          sent_byte_counter++;
  81   4                      }
  82   3      
  83   3                      // need to add an acknowledge here????
  84   3                      // added an ack here
  85   3                      SMB0CN0_ACK = 1;// send an acknowledge that address and command are received
  86   3      
  87   3                      break;
  88   3      
  89   3                              // Slave Receiver: Data received
  90   3                              case SMB_SRDB:
  91   3                      if (rec_byte_counter < NUM_BYTES_WR)
  92   3                      {
  93   4                          // Store incoming data
  94   4                          SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT;
  95   4                          rec_byte_counter++;
  96   4                          SMB0CN0_ACK = 1;         // SMB0CN0_ACK received data
  97   4                      }
  98   3                      else
  99   3                      {
 100   4                          // Store incoming data
 101   4                          SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT;
 102   4                          DATA_READY = 1;         // Indicate new data fully received
 103   4                      }
 104   3                      writelen++;                 // increment global write length counter
 105   3                      break;
 106   3      
 107   3                              // Slave Receiver: Stop received while either a Slave Receiver or
 108   3                              // Slave Transmitter
 109   3                              case SMB_SRSTO:
 110   3                      SMB0CN0_STO = 0;            // SMB0CN0_STO must be cleared by software when
 111   3                                                  // a STOP is detected as a slave
 112   3      
 113   3                      DATA_READY = 1;             // Indicates end of transmission
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        10/24/2016 21:38:09 PAGE 3   

 114   3                      break;
 115   3      
 116   3                              // Slave Transmitter: Data byte transmitted
 117   3                              case SMB_STDB:
 118   3                      if (SMB0CN0_ACK == 1)// If Master SMB0CN0_ACK's, send the next byte
 119   3                      {
 120   4                          if (sent_byte_counter <= NUM_BYTES_RD)
 121   4                          {
 122   5                              // Prepare next outgoing byte
 123   5                              SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
 124   5                              sent_byte_counter++;
 125   5                          }
 126   4                      }                          // Otherwise, do nothing
 127   3                      break;
 128   3      
 129   3                              // Slave Transmitter: Arbitration lost, Stop detected
 130   3                              //
 131   3                              // This state will only be entered on a bus error condition.
 132   3                              // In normal operation, the slave is no longer sending data or has
 133   3                              // data pending when a STOP is received from the master, so the SMB0CN0_TXMODE
 134   3                              // bit is cleared and the slave goes to the SRSTO state.
 135   3                              case SMB_STSTO:
 136   3                      SMB0CN0_STO = 0;            // SMB0CN0_STO must be cleared by software when
 137   3                                                  // a STOP is detected as a slave
 138   3                      break;
 139   3      
 140   3                // Default: all other cases undefined
 141   3                  default:
 142   3                      SMB0CF &= ~0x80;// Reset communication
 143   3                      SMB0CF |= 0x80;
 144   3                      SMB0CN0_STA = 0;
 145   3                      SMB0CN0_STO = 0;
 146   3                      SMB0CN0_ACK = 1;
 147   3                      break;
 148   3                      }
 149   2              }
 150   1              // SMB0CN0_ARBLOST = 1, Abort failed transfer
 151   1              else
 152   1              {
 153   2                      SMB0CN0_STA = 0;
 154   2                      SMB0CN0_STO = 0;
 155   2                      SMB0CN0_ACK = 1;
 156   2              }
 157   1      
 158   1              SMB0CN0_SI = 0;                     // Clear SMBus interrupt flag
 159   1      }
 160          
 161          //-----------------------------------------------------------------------------
 162          // ADC0EOC_ISR
 163          //-----------------------------------------------------------------------------
 164          //
 165          // ADC0EOC ISR Content goes here. Remember to clear flag bits:
 166          // ADC0CN0::ADINT (Conversion Complete Interrupt Flag)
 167          //
 168          //-----------------------------------------------------------------------------
 169          SI_INTERRUPT (ADC0EOC_ISR, ADC0EOC_IRQn)
 170          {
 171   1                 static uint32_t accumulator = 0;         // Accumulator for averaging
 172   1                 static uint16_t measurements = SAMPLING_NUMBER; // Measurement counter
 173   1      
 174   1                 uint32_t temp_adc;                                           // ADC reading of temperature
 175   1      
 176   1                 ADC0CN0_ADINT = 0;                       // Clear ADC0 conv. complete flag
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        10/24/2016 21:38:09 PAGE 4   

 177   1      
 178   1                 // Checks if obtained the necessary number of samples
 179   1                 if(measurements == 0)
 180   1                 {
 181   2                    ADC_SUM = accumulator;           // Copy total into ADC_SUM
 182   2                    measurements = SAMPLING_NUMBER;  // Reset counter
 183   2                    accumulator = 0;                 // Reset accumulator
 184   2      
 185   2                    // conversion is complete, perform calculation and store it in memory
 186   2                    temp_adc = ((ADC_SUM - TOFFSET)/TSLOPE);
 187   2                    temp_val = (char) (temp_adc);        // convert to 8-bit
 188   2      
 189   2                    TSUM[0] = ADC_SUM & 0xff;
 190   2                    TSUM[1] = (ADC_SUM >> 8) & 0xff;
 191   2                    TSUM[2] = (ADC_SUM >> 16) & 0xff;
 192   2                    TSUM[3] = (ADC_SUM >> 24) & 0xff;
 193   2                 }
 194   1                 else
 195   1                 {
 196   2                    TADCL = ADC0 & 0xff;                                 // store higher byte
 197   2                    TADCH = (ADC0 >> 8) & 0xff;                  // store lower byte
 198   2                        accumulator += ADC0 & 0x0fff;       // get 12 bit value (only)
 199   2                    measurements--;
 200   2                 }
 201   1      }
 202          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    373    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     20       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
