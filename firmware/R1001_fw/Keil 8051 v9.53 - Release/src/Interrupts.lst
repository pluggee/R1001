C51 COMPILER V9.53.0.0   INTERRUPTS                                                        09/10/2016 15:09:31 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE INTERRUPTS
OBJECT MODULE PLACED IN .\src/Interrupts.OBJ
COMPILER INVOKED BY: Z:\Applications\SimplicityStudio_v3\developer\toolchains\keil_8051\9.53\BIN\C51.exe /Users/sherifei
                    -d/plugge_git/R1001/firmware/R1001_fw/src/Interrupts.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LARGE) WARNINGLEVEL(2) FLOATFUZZ
                    -Y(3) OPTIMIZE(9,SPEED) DEFINE(NDEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(/Users/sherifeid/plugge_git/R1001/firmware/R
                    -1001_fw/inc;/Applications/SimplicityStudio_v3/developer/sdks/si8051/v3//Device/shared/si8051Base;/Applications/Simplicit
                    -yStudio_v3/developer/sdks/si8051/v3//Device/EFM8BB1;/Applications/SimplicityStudio_v3/developer/sdks/si8051/v3//Device/E
                    -FM8BB1/inc) REGFILE(R1001_fw.ORC) PRINT(.\src/Interrupts.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src/Interrupts
                    -.OBJ)

line level    source

   1          //=========================================================
   2          // src/Interrupts.c: generated by Hardware Configurator
   3          //
   4          // This file will be regenerated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!
   7          //=========================================================
   8          
   9          // USER INCLUDES
  10          #include <SI_EFM8BB1_Register_Enums.h>
  11          #include "compiler_defs.h"
  12          #include "i2c.h"
  13          #include "global.h"
  14          #include "math.h"
  15          
  16          
  17          //extern uint32_t ADC_SUM;               // Accumulates the ADC samples
  18          //extern bit CONV_COMPLETE;              // ADC accumulated result ready flag
  19          
  20          uint32_t ADC_SUM;               // Accumulates the ADC samples
  21          //bit CONV_COMPLETE;              // ADC accumulated result ready flag
  22          char temp_val;
  23          char TSUM[4];                                   // bytes of ADC SUM
  24          char TADCH, TADCL;                              // bytes for single ADC read
  25          
  26          // temperature sensor constants
  27          #define DS_SLOPE                                0.00285         // slope from datasheet in V/C
  28          #define DS_OFFSET                               0.757           // offset from datasheet in V
  29          
  30          #define SAMPLING_2N             4                       // number of samples (power of 2)
  31          #define SAMPLING_NUMBER         16                      // = 2^SAMPLING_2N
  32          #define TSLOPE                  113                     // slope LSB's/C = round(SAMPLING_NUMBER*DS_SLOPE/LSBSize)
  33          #define TOFFSET                 30067           // Offset in LSB's = round(SAMPLING_NUMBER*DS_OFFSET/LSBSize)
  34          
  35          // pin declarations
  36          //SBIT(PWMREF, SFR_P1, 4);                                                      // Driver mode2 pin
  37          
  38          //-----------------------------------------------------------------------------
  39          // TIMER0_ISR
  40          //-----------------------------------------------------------------------------
  41          //
  42          // TIMER0 ISR Content goes here. Remember to clear flag bits:
  43          // TCON::TF0 (Timer 0 Overflow Flag)
  44          //
  45          //-----------------------------------------------------------------------------
  46          SI_INTERRUPT (TIMER0_ISR, TIMER0_IRQn)
  47          {
  48   1      }
  49          
  50          //-----------------------------------------------------------------------------
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        09/10/2016 15:09:31 PAGE 2   

  51          // SMBUS0_ISR
  52          //-----------------------------------------------------------------------------
  53          //
  54          // SMBUS0 ISR Content goes here. Remember to clear flag bits:
  55          // SMB0CN0::SI (SMBus Interrupt Flag)
  56          //
  57          //-----------------------------------------------------------------------------
  58          SI_INTERRUPT (SMBUS0_ISR, SMBUS0_IRQn)
  59          {
  60   1              static uint8_t sent_byte_counter;
  61   1              static uint8_t rec_byte_counter;
  62   1      
  63   1              if (SMB0CN0_ARBLOST == 0)
  64   1              {
  65   2                      switch (SMB0CN0 & 0xF0)          // Decode the SMBus status vector
  66   2                      {
  67   3                              // Slave Receiver: Start+Address received
  68   3                              case SMB_SRADD:
  69   3      
  70   3                              SMB0CN0_STA = 0;// Clear SMB0CN0_STA bit
  71   3      
  72   3                              sent_byte_counter = 1;// Reinitialize the data counters
  73   3                              rec_byte_counter = 1;
  74   3      
  75   3                              if ((SMB0DAT & 0x01) == READ)// If the transfer is a master READ,
  76   3                              {
  77   4                                      // Prepare outgoing byte
  78   4                                      SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
  79   4                                      sent_byte_counter++;
  80   4                              }
  81   3      
  82   3                              // need to add an acknowledge here????
  83   3                              // added an ack here
  84   3                              SMB0CN0_ACK = 1;// send an acknowledge that address and command are received
  85   3      
  86   3                              break;
  87   3      
  88   3                              // Slave Receiver: Data received
  89   3                              case SMB_SRDB:
  90   3      
  91   3                              if (rec_byte_counter < NUM_BYTES_WR)
  92   3                              {
  93   4                                      // Store incoming data
  94   4                                      SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT;
  95   4                                      rec_byte_counter++;
  96   4      
  97   4                                      SMB0CN0_ACK = 1;// SMB0CN0_ACK received data
  98   4                              }
  99   3                              else
 100   3                              {
 101   4                                      // Store incoming data
 102   4                                      SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT;
 103   4      
 104   4                                      DATA_READY = 1;// Indicate new data fully received
 105   4                              }
 106   3      
 107   3                              break;
 108   3      
 109   3                              // Slave Receiver: Stop received while either a Slave Receiver or
 110   3                              // Slave Transmitter
 111   3                              case SMB_SRSTO:
 112   3      
 113   3                              SMB0CN0_STO = 0;// SMB0CN0_STO must be cleared by software when
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        09/10/2016 15:09:31 PAGE 3   

 114   3                                                              // a STOP is detected as a slave
 115   3      
 116   3                              DATA_READY = 1;// Indicates end of transmission
 117   3      
 118   3                              break;
 119   3      
 120   3                              // Slave Transmitter: Data byte transmitted
 121   3                              case SMB_STDB:
 122   3      
 123   3                              if (SMB0CN0_ACK == 1)// If Master SMB0CN0_ACK's, send the next byte
 124   3                              {
 125   4                                      if (sent_byte_counter <= NUM_BYTES_RD)
 126   4                                      {
 127   5                                              // Prepare next outgoing byte
 128   5                                              SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
 129   5                                              sent_byte_counter++;
 130   5                                      }
 131   4                              }                          // Otherwise, do nothing
 132   3                              break;
 133   3      
 134   3                              // Slave Transmitter: Arbitration lost, Stop detected
 135   3                              //
 136   3                              // This state will only be entered on a bus error condition.
 137   3                              // In normal operation, the slave is no longer sending data or has
 138   3                              // data pending when a STOP is received from the master, so the SMB0CN0_TXMODE
 139   3                              // bit is cleared and the slave goes to the SRSTO state.
 140   3                              case SMB_STSTO:
 141   3      
 142   3                              SMB0CN0_STO = 0;// SMB0CN0_STO must be cleared by software when
 143   3                                                              // a STOP is detected as a slave
 144   3                              break;
 145   3      
 146   3                                                              // Default: all other cases undefined
 147   3                              default:
 148   3      
 149   3                              SMB0CF &= ~0x80;// Reset communication
 150   3                              SMB0CF |= 0x80;
 151   3                              SMB0CN0_STA = 0;
 152   3                              SMB0CN0_STO = 0;
 153   3                              SMB0CN0_ACK = 1;
 154   3                              break;
 155   3                      }
 156   2              }
 157   1              // SMB0CN0_ARBLOST = 1, Abort failed transfer
 158   1              else
 159   1              {
 160   2                      SMB0CN0_STA = 0;
 161   2                      SMB0CN0_STO = 0;
 162   2                      SMB0CN0_ACK = 1;
 163   2              }
 164   1      
 165   1              SMB0CN0_SI = 0;                     // Clear SMBus interrupt flag
 166   1      }
 167          
 168          //-----------------------------------------------------------------------------
 169          // ADC0EOC_ISR
 170          //-----------------------------------------------------------------------------
 171          //
 172          // ADC0EOC ISR Content goes here. Remember to clear flag bits:
 173          // ADC0CN0::ADINT (Conversion Complete Interrupt Flag)
 174          //
 175          //-----------------------------------------------------------------------------
 176          SI_INTERRUPT (ADC0EOC_ISR, ADC0EOC_IRQn)
C51 COMPILER V9.53.0.0   INTERRUPTS                                                        09/10/2016 15:09:31 PAGE 4   

 177          {
 178   1                 static uint32_t accumulator = 0;         // Accumulator for averaging
 179   1                 static uint16_t measurements = SAMPLING_NUMBER; // Measurement counter
 180   1      
 181   1                 uint32_t temp_adc;                                           // ADC reading of temperature
 182   1      
 183   1                 ADC0CN0_ADINT = 0;                       // Clear ADC0 conv. complete flag
 184   1      
 185   1                 // Checks if obtained the necessary number of samples
 186   1                 if(measurements == 0)
 187   1                 {
 188   2                    ADC_SUM = accumulator;           // Copy total into ADC_SUM
 189   2                    measurements = SAMPLING_NUMBER;  // Reset counter
 190   2                    accumulator = 0;                 // Reset accumulator
 191   2      
 192   2                    // conversion is complete, perform calculation and store it in memory
 193   2                    temp_adc = ((ADC_SUM - TOFFSET)/TSLOPE);
 194   2                    temp_val = (char) (temp_adc);        // convert to 8-bit
 195   2      
 196   2                    TSUM[0] = ADC_SUM & 0xff;
 197   2                    TSUM[1] = (ADC_SUM >> 8) & 0xff;
 198   2                    TSUM[2] = (ADC_SUM >> 16) & 0xff;
 199   2                    TSUM[3] = (ADC_SUM >> 24) & 0xff;
 200   2                 }
 201   1                 else
 202   1                 {
 203   2                    TADCL = ADC0 & 0xff;                                 // store higher byte
 204   2                    TADCH = (ADC0 >> 8) & 0xff;                  // store lower byte
 205   2                        accumulator += ADC0 & 0x0fff;       // get 12 bit value (only)
 206   2                    measurements--;
 207   2                 }
 208   1      }
 209          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    375    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     19       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
